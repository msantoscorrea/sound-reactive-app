{"version":3,"sources":["src/index.js"],"names":["require","el","document","querySelector","sourceStr","strArray","split","bins","initElements","i","length","letter","phraseAtom","createElement","innerText","appendChild","init","initVisualizer","undefined","navigator","mediaDevices","getUserMedia","constraints","webkitGetUserMedia","mozGetUserMedia","Promise","resolve","reject","call","Error","audio","then","stream","audioCtx","window","AudioContext","webkitAudioContext","analyser","createAnalyser","minDecibels","maxDecibels","smoothingTimeConstant","createMediaStreamSource","connect","fftSize","dataArray","Uint8Array","avgHistory","requestAnimationFrame","draw","now","getByteFrequencyData","avg","els","childNodes","push","shift","style","fontVariationSettings","concat","map","setFontFeatures","catch","err","console","log","value","min1","max1","min2","max2","addEventListener"],"mappings":";;;AAyHA,aAzHAA,QAAA,gBAEA,IAAMC,EAAKC,SAASC,cAAc,WAC5BC,EAAY,mBACZC,EAAWD,EAAUE,MAAM,IAE7BC,EAAO,GAEX,SAASC,IACP,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAASK,OAAQD,IAAK,CACxC,IAAME,EAASN,EAASI,GAElBG,EAAaV,SAASW,cAAc,QAC1CD,EAAWE,UAAYH,EACvBV,EAAGc,YAAYH,IAInB,SAASI,IACPC,IACAT,IAKF,SAASS,SAEwBC,IAA3BC,UAAUC,eACZD,UAAUC,aAAe,SAMiBF,IAAxCC,UAAUC,aAAaC,eACzBF,UAAUC,aAAaC,aAAe,SAAUC,GAE9C,IAAID,EACFF,UAAUI,oBAAsBJ,UAAUK,gBAI5C,OAAKH,EAOE,IAAII,QAAQ,SAAUC,EAASC,GACpCN,EAAaO,KAAKT,UAAWG,EAAaI,EAASC,KAP5CF,QAAQE,OACb,IAAIE,MAAM,sDAWlBV,UAAUC,aACPC,aAAa,CAAES,OAAO,IACtBC,KAAK,SAAUC,GAGd,IAAIC,EAAW,IAAKC,OAAOC,cAAgBD,OAAOE,oBAE9CC,EAAWJ,EAASK,iBACxBD,EAASE,aAAe,GACxBF,EAASG,aAAe,GACxBH,EAASI,sBAAwB,GAEpBR,EAASS,wBAAwBV,GACvCW,QAAQN,GAEfA,EAASO,QAAiB,EAAPrC,EAEnB,IAAIsC,EAAY,IAAIC,WAAWvC,GAEzBwC,EAAa,GAqCnBC,sBAfA,SAASC,EAAKC,GACZb,EAASc,qBAAqBN,GAI9B,IADA,IAAIO,EAAM,EACD3C,EAAI,EAAGA,EAAIF,EAAME,IACxB2C,GAAOP,EAAUpC,IA1BrB,SAAyB2C,GACvB,IAAMC,EAAMpD,EAAGqD,WAEfP,EAAWQ,KAAKH,GACZL,EAAWrC,OAAS2C,EAAI3C,QAC1BqC,EAAWS,QAGb,IAAK,IAAI/C,EAAI4C,EAAI3C,OAAS,EAAGD,GAAK,EAAGA,IACxB4C,EAAI5C,GACZgD,MAAMC,sBAAqBC,UAAAA,OAAaC,EACzCb,EAAWtC,GACX,EACA,GACA,GACA,OAeJoD,CAFAT,GAAO7C,GAIPyC,sBAAsBC,OAKzBa,MAAM,SAAUC,GACfC,QAAQC,IAAI,gCAAkCF,KAIpD,SAASH,EAAIM,EAAOC,EAAMC,EAAMC,EAAMC,GAEpC,OADoBJ,EAAQC,IAASC,EAAOD,IAAUG,EAAOD,GAAQA,EAhGvEnC,OAAOqC,iBAAiB,OAAQvD,KAAQ","file":"src.8b9a0716.js","sourceRoot":"..","sourcesContent":["import \"./styles.css\";\n\nconst el = document.querySelector(\"#app h1\");\nconst sourceStr = \"Clap your hands!\";\nconst strArray = sourceStr.split(\"\");\n\nvar bins = 16;\n\nfunction initElements() {\n  for (let i = 0; i < strArray.length; i++) {\n    const letter = strArray[i];\n\n    const phraseAtom = document.createElement(\"SPAN\");\n    phraseAtom.innerText = letter;\n    el.appendChild(phraseAtom);\n  }\n}\n\nfunction init() {\n  initVisualizer();\n  initElements();\n}\n\nwindow.addEventListener(\"load\", init(), false);\n\nfunction initVisualizer() {\n  // Older browsers might not implement mediaDevices at all, so we set an empty object first\n  if (navigator.mediaDevices === undefined) {\n    navigator.mediaDevices = {};\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n  if (navigator.mediaDevices.getUserMedia === undefined) {\n    navigator.mediaDevices.getUserMedia = function (constraints) {\n      // First get ahold of the legacy getUserMedia, if present\n      var getUserMedia =\n        navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n\n      // Some browsers just don't implement it - return a rejected promise with an error\n      // to keep a consistent interface\n      if (!getUserMedia) {\n        return Promise.reject(\n          new Error(\"getUserMedia is not implemented in this browser\")\n        );\n      }\n\n      // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\n      return new Promise(function (resolve, reject) {\n        getUserMedia.call(navigator, constraints, resolve, reject);\n      });\n    };\n  }\n\n  navigator.mediaDevices\n    .getUserMedia({ audio: true })\n    .then(function (stream) {\n      // Set up a Web Audio AudioContext and AnalyzerNode, configured to return the\n      // same number of bins of audio frequency data.\n      var audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n\n      var analyser = audioCtx.createAnalyser();\n      analyser.minDecibels = -70;\n      analyser.maxDecibels = -10;\n      analyser.smoothingTimeConstant = 0.5;\n\n      var source = audioCtx.createMediaStreamSource(stream);\n      source.connect(analyser);\n\n      analyser.fftSize = bins * 2;\n\n      var dataArray = new Uint8Array(bins);\n\n      const avgHistory = [];\n\n      function setFontFeatures(avg) {\n        const els = el.childNodes;\n\n        avgHistory.push(avg);\n        if (avgHistory.length > els.length) {\n          avgHistory.shift();\n        }\n\n        for (let i = els.length - 1; i >= 0; i--) {\n          const el = els[i];\n          el.style.fontVariationSettings = `\"wght\" ${map(\n            avgHistory[i],\n            0,\n            64,\n            10,\n            100\n          )}`;\n        }\n      }\n\n      function draw(now) {\n        analyser.getByteFrequencyData(dataArray);\n\n        // Use that data to drive updates to the fill-extrusion-height property.\n        let avg = 0;\n        for (var i = 0; i < bins; i++) {\n          avg += dataArray[i];\n        }\n        avg /= bins;\n\n        setFontFeatures(avg);\n\n        requestAnimationFrame(draw);\n      }\n\n      requestAnimationFrame(draw);\n    })\n    .catch(function (err) {\n      console.log(\"The following error occured: \" + err);\n    });\n}\n\nfunction map(value, min1, max1, min2, max2) {\n  var returnvalue = ((value - min1) / (max1 - min1)) * (max2 - min2) + min2;\n  return returnvalue;\n}\n"]}